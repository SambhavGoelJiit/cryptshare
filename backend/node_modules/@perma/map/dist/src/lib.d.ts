export * from "./api.js";
export function empty<V = unknown, K extends string = string, C extends Node.Config<any, any> = Node.Config<number, number>>(options?: Partial<C> | undefined): Node.PersistentHashMap<V, K, C>;
export function from<V = unknown, K extends string = string, C extends Node.Config<any, any> = Node.Config<number, number>>(entries: Iterable<[K, V]>, options?: Partial<C> | undefined): Node.PersistentHashMap<V, K, C>;
export function has<T, K extends string>(hamt: Node.HAMT<T, K, Node.Config<unknown, unknown>>, key: K): boolean;
export function get<T, K extends string, U = undefined>(hamt: Node.HAMT<T, K, Node.Config<unknown, unknown>>, key: K, notFound?: U): T | U;
export function builder<K extends string, T, C extends Node.Config<any, any>>(options?: Partial<C> | undefined): Node.HashMapBuilder<T, K, C>;
import * as Node from "./node.js";
import * as API from "./api.js";
/**
 * @template T
 * @template {string} K
 * @template {API.Config} C
 * @implements {API.PersistentHashMap<T, K, C>}
 */
declare class PersistentHashMap<T, K extends string, C extends Node.Config<any, any>> implements API.PersistentHashMap<T, K, C> {
    /**
     *
     * @param {number} count
     * @param {API.BitmapIndexedNode<T, K, C>} root
     * @param {C} config
     */
    constructor(count: number | undefined, root: API.BitmapIndexedNode<T, K, C>, config: C);
    count: number;
    root: Node.BitmapIndexedNode<T, K, C>;
    config: C;
    get size(): number;
    clone(): PersistentHashMap<T, K, C>;
    /**
     * @returns {API.PersistentHashMap<T, K, C>}
     */
    empty(): API.PersistentHashMap<T, K, C>;
    /**
     * @param {K} key
     * @returns {boolean}
     */
    has(key: K): boolean;
    /**
     * @param {K} key
     * @returns {T|undefined}
     */
    get(key: K): T | undefined;
    /**
     * @template {string} R
     * @param {R} key
     * @param {T} value
     * @returns {PersistentHashMap<T, K|R, C>}
     */
    set<R extends string>(key: R, value: T): PersistentHashMap<T, K | R, C>;
    /**
     * @param {K} key
     */
    delete(key: K): PersistentHashMap<T, K, C>;
    get bitField(): any;
    entries(): IterableIterator<[K, T]>;
    keys(): IterableIterator<K>;
    values(): IterableIterator<T>;
    /**
     * @returns {API.HashMapBuilder<T, K, C>}
     */
    createBuilder(): API.HashMapBuilder<T, K, C>;
    [Symbol.iterator](): IterableIterator<[K, T]>;
}
/**
 * @template T
 * @template {string} K
 * @template {API.Config} C
 */
declare class HashMapBuilder<T, K extends string, C extends Node.Config<any, any>> {
    /**
     * @param {API.Edit} edit
     * @param {number} count
     * @param {API.BitmapIndexedNode<T, K, C>} root
     * @param {C} config
     */
    constructor(edit: API.Edit, count: number, root: API.BitmapIndexedNode<T, K, C>, config: C);
    /**
     * @type {API.Edit|null}
     * @private
     */
    private edit;
    /**
     * @private
     */
    private count;
    root: Node.BitmapIndexedNode<T, K, C>;
    config: C;
    get size(): number;
    /**
     * @template {string} R
     * @param {R} key
     * @param {T} value
     * @returns {HashMapBuilder<T, K|R, C>}
     */
    set<R extends string>(key: R, value: T): HashMapBuilder<T, K | R, C>;
    /**
     * @param {K} key
     */
    delete(key: K): HashMapBuilder<T, K, C>;
    build(): PersistentHashMap<T, K, C>;
}
//# sourceMappingURL=lib.d.ts.map