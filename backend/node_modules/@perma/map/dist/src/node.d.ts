export * from "./api.js";
export function lookupCollision<T, K extends string, C extends API.Config<any, any>, X>(node: API.HashCollisionNode<T, K, C>, name: K, notFound: X): T | X;
export function associateCollision<T, K extends string, C extends API.Config<any, any>, R extends string>(node: API.HashCollisionNode<T, K, C>, edit: API.Edit | null, key: ReturnType<C["Path"]["from"]>, name: K | R, value: T, addedLeaf: {
    value: boolean;
}): API.HashCollisionNode<T, K | R, C>;
export function dissociateCollision<T, K extends string, C extends API.Config<any, any>>(node: API.HashCollisionNode<T, K, C>, edit: API.Edit | null, hash: ReturnType<C["Path"]["from"]>, name: K, removedLeaf: {
    value: boolean;
}): API.Node<T, K, C>;
export function forkCollision<T, K extends string, C extends API.Config<any, any>>(node: API.HashCollisionNode<T, K, C>, edit?: API.Edit | null): API.HashCollisionNode<T, K, C>;
export function create<T, K extends string, C extends API.Config<any, any>>(config: C, edit?: API.Edit | null | undefined): API.BitmapIndexedNode<T, K, C>;
export function get<T, U, K extends string>(node: API.BitmapIndexedNode<T, K, API.Config<unknown, unknown>>, key: K, notFound: U): T | U;
export function lookup<T, U, K extends string, Bits, BitMap>(node: API.BitmapIndexedNode<T, K, API.Config<Bits, BitMap>>, depth: API.Uint32, path: Bits, key: K, notFound: U): T | U;
export function set<T, U, K extends string, R extends string, C extends API.Config<any, any>>(node: API.BitmapIndexedNode<T, K, C>, edit: API.Edit | null, key: R, value: T, addedLeaf: {
    value: boolean;
}): API.BitmapIndexedNode<T, K | R, C>;
export function associate<T, K extends string, R extends string, C extends API.Config<any, any>>(node: API.BitmapIndexedNode<T, K, C>, edit: API.Edit | null, depth: API.Uint32, path: ReturnType<C["Path"]["from"]>, key: K | R, value: T, addedLeaf: {
    value: boolean;
}): API.BitmapIndexedNode<T, K | R, C>;
export function dissociate<T, K extends string, C extends API.Config<any, any>>(source: API.BitmapIndexedNode<T, K, C>, edit: API.Edit | null, depth: API.Uint32, path: ReturnType<C["Path"]["from"]>, key: K, removedLeaf: {
    value: boolean;
}): API.BitmapIndexedNode<T, K, C>;
export function entries<T, K extends string, C extends API.Config<any, any>>({ children }: API.Node<T, K, C>): IterableIterator<[K, T]>;
export function fork<T, K extends string, C extends API.Config<any, any>>(node: API.BitmapIndexedNode<T, K, C>, edit: API.Edit | null): API.BitmapIndexedNode<T, K, C>;
export function keys<T, K extends string, C extends API.Config<any, any>>({ children }: API.Node<T, K, C>): IterableIterator<K>;
export function values<T, K extends string, C extends API.Config<any, any>>({ children }: API.Node<T, K, C>): IterableIterator<T>;
export function forkAndSet<T, K extends string, C extends API.Config<any, any>>(node: API.BitmapIndexedNode<T, K, C>, edit: API.Edit | null, offset: number, value: T): API.BitmapIndexedNode<T, K, C>;
export function inlineChild<T, K extends string, C extends API.Config<any, any>>(source: API.BitmapIndexedNode<T, K, C>, edit: API.Edit | null, offset: number, child: API.Node<T, K, C>): API.BitmapIndexedNode<T, K, C>;
export function copyAndSetChild<T, K extends string, C extends API.Config<any, any>>(node: API.BitmapIndexedNode<T, K, C>, edit: API.Edit | null, offset: number, child: API.Node<T, K, C>): API.BitmapIndexedNode<T, K, C>;
export function migrateLeafToBranch<T, K extends string, C extends API.Config<any, any>>(source: API.BitmapIndexedNode<T, K, C>, edit: API.Edit | null, offset: number, branch: API.Node<T, K, C>): API.BitmapIndexedNode<T, K, C>;
export function mergeTwoLeaves<T, K extends string, C extends API.Config<any, any>>(config: C, edit: API.Edit | null, depth: number, oldPath: ReturnType<C["Path"]["from"]>, oldKey: K, oldValue: T, newPath: ReturnType<C["Path"]["from"]>, newKey: K, newValue: T): API.Node<T, K, C>;
export function keyAt<K extends string>({ children }: API.BitmapIndexedNode<unknown, K, API.Config<unknown, unknown>>, index: number): K;
export function keyPosition(index: number): number;
export function valueAt<T>({ children }: API.BitmapIndexedNode<T, string, API.Config<unknown, unknown>>, index: number): T;
export function valuePosition(index: number): number;
export function resolveNode<T, K extends string, C extends API.Config<any, any>>(node: API.BitmapIndexedNode<T, K, C>, offset: number): API.BitmapIndexedNode<T, K, C> | API.HashCollisionNode<T, K, C>;
import * as API from "./api.js";
/**
 * @template T
 * @template {string} K
 * @template {API.Config} C
 * @implements {API.HashCollisionNode<T, K, C>}
 */
declare class HashCollisionNode<T, K extends string, C extends API.Config<any, any>> implements API.HashCollisionNode<T, K, C> {
    /**
     * @param {API.Edit|null} edit
     * @param {number} count
     * @param {API.CollisionEntries<T, K>} children
     * @param {C} config
     */
    constructor(edit: API.Edit | null, count: number, children: API.CollisionEntries<T, K>, config: C);
    edit: API.Edit | null;
    count: number;
    children: API.CollisionEntries<T, K>;
    config: C;
    get nodeArity(): 0;
    get dataArity(): number;
    /**
     * @template X
     * @param {API.Uint32} _shift
     * @param {unknown} _path
     * @param {K} key
     * @param {X} notFound
     * @returns {T|X}
     */
    lookup<X>(_shift: API.Uint32, _path: unknown, key: K, notFound: X): T | X;
    /**
     * @template {string} R
     * @param {API.Edit|null} edit
     * @param {API.Uint32} _shift
     * @param {ReturnType<C['Path']['from']>} path
     * @param {K|R} key
     * @param {T} value
     * @param {{value:boolean}} addedLeaf
     * @returns {API.HashCollisionNode<T, K | R, C>}
     */
    associate<R extends string>(edit: API.Edit | null, _shift: API.Uint32, path: ReturnType<C['Path']['from']>, key: K | R, value: T, addedLeaf: {
        value: boolean;
    }): API.HashCollisionNode<T, K | R, C>;
    /**
     * @param {API.Edit|null} edit
     * @param {API.Uint32} _shift
     * @param {ReturnType<C['Path']['from']>} path
     * @param {K} key
     * @param {{value:boolean}} removedLeaf
     * @returns {API.Node<T, K, C>}
     */
    dissociate(edit: API.Edit | null, _shift: API.Uint32, path: ReturnType<C['Path']['from']>, key: K, removedLeaf: {
        value: boolean;
    }): API.Node<T, K, C>;
    /**
     * @param {API.Edit|null} edit
     * @returns {this}
     */
    fork(edit?: API.Edit | null): this;
    /**
     * @returns {IterableIterator<[K, T]>}
     */
    entries(): IterableIterator<[K, T]>;
    /**
     * @returns {IterableIterator<K>}
     */
    keys(): IterableIterator<K>;
    /**
     * @returns {IterableIterator<T>}
     */
    values(): IterableIterator<T>;
}
/**
 * @template T
 * @template {string} K
 * @template {API.Config} C
 * @implements {API.BitmapIndexedNode<T, K, C>}
 */
declare class BitmapIndexedNode<T, K extends string, C extends API.Config<any, any>> implements API.BitmapIndexedNode<T, K, C> {
    /**
     * @param {API.Edit|null} edit
     * @param {ReturnType<C['BitField']['empty']>} datamap
     * @param {ReturnType<C['BitField']['empty']>} nodemap
     * @param {API.Children<T, K, C>} children
     * @param {C} config
     */
    constructor(edit: API.Edit | null, datamap: ReturnType<C['BitField']['empty']>, nodemap: ReturnType<C['BitField']['empty']>, children: API.Children<T, K, C>, config: C);
    edit: API.Edit | null;
    config: C;
    datamap: ReturnType<C["BitField"]["empty"]>;
    nodemap: ReturnType<C["BitField"]["empty"]>;
    children: API.Children<T, K, C>;
    get nodeArity(): number;
    get dataArity(): number;
    /**
     * @returns {API.BitmapIndexedNode<T, K, C>}
     */
    empty(): API.BitmapIndexedNode<T, K, C>;
    /**
     * @template X
     * @param {API.Uint32} depth
     * @param {ReturnType<C['Path']['from']>} path
     * @param {K} key
     * @param {X} notFound
     * @returns {T|X}
     */
    lookup<X>(depth: API.Uint32, path: ReturnType<C['Path']['from']>, key: K, notFound: X): T | X;
    /**
     * @template {string} R
     * @param {API.Edit|null} edit
     * @param {API.Uint32} depth
     * @param {ReturnType<C['Path']['from']>} path
     * @param {K|R} key
     * @param {T} value
     * @param {{value:boolean}} addedLeaf
     * @returns {API.BitmapIndexedNode<T, K | R, C>}
     */
    associate<R extends string>(edit: API.Edit | null, depth: API.Uint32, path: ReturnType<C['Path']['from']>, key: K | R, value: T, addedLeaf: {
        value: boolean;
    }): API.BitmapIndexedNode<T, K | R, C>;
    /**
     * @param {API.Edit|null} edit
     * @param {API.Uint32} depth
     * @param {ReturnType<C['Path']['from']>} path
     * @param {K} key
     * @param {{value:boolean}} removedLeaf
     * @returns {API.BitmapIndexedNode<T, K, C>}
     */
    dissociate(edit: API.Edit | null, depth: API.Uint32, path: ReturnType<C['Path']['from']>, key: K, removedLeaf: {
        value: boolean;
    }): API.BitmapIndexedNode<T, K, C>;
    /**
     * @param {API.Edit|null} edit
     * @returns {API.BitmapIndexedNode<T, K, C>}
     */
    fork(edit?: API.Edit | null): API.BitmapIndexedNode<T, K, C>;
    /**
     * @returns {IterableIterator<[K, T]>}
     */
    entries(): IterableIterator<[K, T]>;
    /**
     * @returns {IterableIterator<K>}
     */
    keys(): IterableIterator<K>;
    /**
     * @returns {IterableIterator<T>}
     */
    values(): IterableIterator<T>;
}
/**
 * @template T
 * @template {string} K
 * @template {API.Config} C
 * @param {API.BitmapIndexedNode<T, K, C>} node
 * @param {API.Edit|null} edit
 * @param {K} key
 * @param {{ value: boolean }} removedLeaf
 * @returns {API.BitmapIndexedNode<T, K, C>}
 */
declare function remove<T, K extends string, C extends API.Config<any, any>>(node: API.BitmapIndexedNode<T, K, C>, edit: API.Edit | null, key: K, removedLeaf: {
    value: boolean;
}): API.BitmapIndexedNode<T, K, C>;
export { API, remove as delete, _delete as delete };
//# sourceMappingURL=node.d.ts.map