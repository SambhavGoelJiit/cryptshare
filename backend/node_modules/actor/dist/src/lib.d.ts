/**
 * Gets a handle to the task that invoked it. Useful when task needs to
 * suspend execution until some outside event occurs, in which case handle
 * can be used resume execution (see `suspend` code example for more details)
 *
 * @template T, M, X
 * @returns {Task.Task<Task.Controller<T, X, M>, never>}
 */
export function current<T, M, X>(): Task.Task<Task.Controller<T, X, M>, never, never>;
/**
 * Suspends execution for the given duration in milliseconds, after which
 * execution is resumed (unless it was aborted in the meantime).
 *
 * @example
 * ```js
 * function * demo() {
 *    console.log("I'm going to take small nap")
 *    yield * sleep(200)
 *    console.log("I am back to work")
 * }
 * ```
 *
 * @param {number} [duration]
 * @returns {Task.Task<void, never>}
 */
export function sleep(duration?: number | undefined): Task.Task<void, never>;
/**
 * Takes several effects and combines them into a one.
 *
 * @template T
 * @param {Task.Effect<T>[]} effects
 * @returns {Task.Effect<T>}
 */
export function batch<T>(effects: Task.Effect<T>[]): Task.Effect<T>;
/**
 * Kind of like promise.then which is handy when you want to extract result
 * from the given task from the outside.
 *
 * @template T, U, X, M
 * @param {Task.Task<T, X, M>} task
 * @param {(value:T) => U} resolve
 * @param {(error:X) => U} reject
 * @returns {Task.Task<U, never, M>}
 */
export function then<T, U, X, M>(task: Task.Task<T, X, M>, resolve: (value: T) => U, reject: (error: X) => U): Task.Task<U, never, M>;
/**
 * Executes given task concurrently with a current task (task that spawned it).
 * Spawned task is detached from the task that spawned it and it can outlive it
 * and / or fail without affecting a task that spawned it. If you need to wait
 * on concurrent task completion consider using `fork` instead which can be
 * later `joined`. If you just want a to block on task execution you can just
 * `yield* work()` directly instead.
 *
 * @param {Task.Task<void, never, never>} task
 * @returns {Task.Task<void, never>}
 */
export function spawn(task: Task.Task<void, never, never>): Task.Task<void, never>;
/**
 * Groups multiple forks togather and joins joins them with current task.
 *
 * @template T, X, M
 * @param {Task.Fork<T, X, M>[]} forks
 * @returns {Task.Task<void, X, M>}
 */
export function group<T, X, M>(forks: Task.Fork<T, X, M>[]): Task.Task<void, X, M>;
/**
 * @template T, X, M
 * @param {Task.Fork<T, X, M>} fork
 * @returns {Task.Task<T, X, M>}
 */
export function join<T, X, M>(fork: Task.Fork<T, X, M>): Task.Task<T, X, M>;
export * from "./task.js";
export function effect<T>(task: Task.Task<T, never, never>): Task.Effect<T>;
export function suspend(): Task.Task<void, never>;
export function wait<T, X = unknown>(input: Task.Await<T>): Task.Task<T, Error, never>;
export function send<T>(message: T): Task.Effect<T>;
export function listen<Tag extends string, T>(source: { [K in Tag]: Task.Effect<T>; }): Task.Effect<Task.Tagged<Tag, T>>;
export function effects<Tag extends string, T>(tasks: Task.Task<T, never, never>[]): Task.Effect<T>;
export function tag<Tag extends string, T, M, X>(effect: Task.Task<T, X, M>, tag: Tag): Task.Task<T, X, Task.Tagged<Tag, M>>;
/**
 * Returns empty `Effect`, that is produces no messages. Kind of like `[]` or
 * `""` but for effects.
 *
 * @type {() => Task.Effect<never>}
 */
export const none: () => Task.Effect<never>;
export function all<T, X>(tasks: Iterable<Task.Task<T, X, never>>): Task.Task<T[], X, never>;
export function isMessage<M>(value: Task.Instruction<M>): value is M;
export function isInstruction<M>(value: Task.Instruction<M>): value is Task.Control;
export function main(task: Task.Task<void, never>): void;
export function resume<T, X, M>(task: Task.Controller<T, X, M>): void;
export function fork<T, X, M>(task: Task.Task<T, X, M>, options?: Task.ForkOptions | undefined): Task.Fork<T, X, M>;
export function exit<T, M, X>(handle: Task.Controller<T, M, X>, value: T): Task.Task<void, never>;
export function terminate<M, X>(handle: Task.Controller<void, X, M>): Task.Task<void, never, never> & Task.Controller<void, never, never>;
export function abort<T, M, X>(handle: Task.Controller<T, X, M>, error?: X | undefined): Task.Task<void, never, never> & Task.Controller<void, never, never>;
export function loop<M>(init: Task.Effect<M>, next: (message: M) => Task.Effect<M>): Task.Task<void, never, never>;
export type Tagged<Tag extends string, T> = {
    type: Tag;
} & { [K in Tag]: T; };
export type Control = typeof SUSPEND | typeof CURRENT;
import * as Task from "./task.js";
/**
 * @template T, X, M
 * @implements {Task.Fork<T, X, M>}
 * @implements {Task.Controller<T, X, M>}
 * @implements {Task.Task<Task.Fork<T, X, M>, never>}
 * @implements {Task.Future<T, X>}
 * @extends {Future<T, X>}
 */
declare class Fork<T, X, M> extends Future<T, X> implements Task.Fork<T, X, M>, Task.Controller<T, X, M>, Task.Task<Task.Fork<T, X, M>, never>, Task.Future<T, X> {
    /**
     * @param {Task.Task<T, X, M>} task
     * @param {Task.ForkOptions} [options]
     * @param {Task.StateHandler<T, X>} [handler]
     * @param {Task.TaskState<T, M>} [state]
     */
    constructor(task: Task.Task<T, X, M>, options?: Task.ForkOptions | undefined, handler?: Task.StateHandler<T, X> | undefined, state?: Task.TaskState<T, M> | undefined);
    id: number;
    name: string;
    /** @type {Task.Task<T, X, M>} */
    task: Task.Task<T, X, M>;
    state: Task.TaskState<T, M>;
    status: Task.Status;
    /** @type {Task.Controller<T, X, M>} */
    controller: Task.Controller<T, X, M>;
    resume(): Generator<never, void, unknown>;
    /**
     * @returns {Task.Task<T, X, M>}
     */
    join(): Task.Task<T, X, M>;
    /**
     * @param {X} error
     */
    abort(error: X): Task.Task<void, never, never> & Task.Controller<void, never, never>;
    /**
     * @param {T} value
     */
    exit(value: T): Task.Task<void, never, never>;
    /**
     * @private
     * @param {any} error
     * @returns {never}
     */
    private panic;
    /**
     * @private
     * @param {Task.TaskState<T, M>} state
     */
    private step;
    /**
     * @param {unknown} value
     */
    next(value: unknown): Task.TaskState<T, M>;
    /**
     * @param {T} value
     */
    return(value: T): Task.TaskState<T, M>;
    /**
     * @param {X} error
     */
    throw(error: X): Task.TaskState<T, M>;
    get [Symbol.toStringTag](): string;
    /**
     * @returns {Task.Controller<Task.Fork<T, X, M>, never, never>}
     */
    [Symbol.iterator](): Task.Controller<Task.Fork<T, X, M>, never, never>;
}
declare const SUSPEND: unique symbol;
declare const CURRENT: unique symbol;
/**
 * @template T, X
 * @implements {Task.Future<T, X>}
 */
declare class Future<T, X> implements Task.Future<T, X> {
    /**
     * @param {Task.StateHandler<T, X>} handler
     */
    constructor(handler: Task.StateHandler<T, X>);
    handler: Task.StateHandler<T, X>;
    /**
     * @abstract
     * @type {Task.Result<T, X>|void}
     */
    result: Task.Result<T, X> | void;
    /**
     * @type {Promise<T>}
     */
    get promise(): Promise<T>;
    /**
     * @template U, [E=never]
     * @param {((value:T) => U | PromiseLike<U>)|undefined|null} [onresolve]
     * @param {((error:X) => E|PromiseLike<E>)|undefined|null} [onreject]
     * @returns {Promise<U|E>}
     */
    then<U, E = never>(onresolve?: ((value: T) => U | PromiseLike<U>) | null | undefined, onreject?: ((error: X) => E | PromiseLike<E>) | null | undefined): Promise<U | E>;
    /**
     * @template [U=never]
     * @param {(error:X) => U} onreject
     */
    catch<U_1 = never>(onreject: (error: X) => U_1): Task.Future<T | U_1, never>;
    /**
     * @param {() => void} onfinally
     * @returns {Task.Future<T, X>}
     */
    finally(onfinally: () => void): Task.Future<T, X>;
    /**
     * @abstract
     */
    activate(): Future<T, X>;
}
//# sourceMappingURL=lib.d.ts.map