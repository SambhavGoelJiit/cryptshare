/**
 * @template {UCAN.Capabilities} C
 */
export class View<C extends UCAN.Capabilities> {
    /**
     * @param {UCAN.UCAN<C>} model
     */
    constructor(model: UCAN.UCAN<C>);
    /** @readonly */
    readonly model: UCAN.UCAN<C>;
    get version(): `${number}.${number}.${number}`;
    get issuer(): UCAN.PrincipalView<`did:${string}:${string}`>;
    get audience(): UCAN.PrincipalView<`did:${string}:${string}`>;
    /**
     * @returns {C}
     */
    get capabilities(): C;
    /**
     * @returns {number}
     */
    get expiration(): number;
    /**
     * @returns {undefined|number}
     */
    get notBefore(): number | undefined;
    /**
     * @returns {undefined|string}
     */
    get nonce(): string | undefined;
    /**
     * @returns {UCAN.Fact[]}
     */
    get facts(): UCAN.Fact[];
    /**
     * @returns {UCAN.Link[]}
     */
    get proofs(): UCAN.Link<UCAN.Capabilities, UCAN.MulticodecCode<number, string>, UCAN.SigAlg>[];
    get signature(): UCAN.SignatureView<unknown, UCAN.SigAlg>;
    get jwt(): UCAN.JWT<C> | undefined;
    get s(): UCAN.SignatureView<unknown, UCAN.SigAlg>;
    get v(): `${number}.${number}.${number}`;
    get iss(): UCAN.Issuer;
    get aud(): UCAN.Audience;
    get att(): C;
    get exp(): number | null;
    get nbf(): number | undefined;
    get nnc(): string | undefined;
    get fct(): UCAN.Fact[];
    get prf(): UCAN.Link<UCAN.Capabilities, UCAN.MulticodecCode<number, string>, UCAN.SigAlg>[];
    /**
     * @returns {UCAN.ToJSON<UCAN.UCAN<C>, UCAN.UCANJSON<this>>}
     */
    toJSON(): UCAN.ToJSON<UCAN.UCAN<C>, UCAN.UCANJSON<View<C>>>;
}
import * as UCAN from "./ucan.js";
//# sourceMappingURL=view.d.ts.map