export const NON_STANDARD: 53248;
export const ES256K: 53479;
export const BLS12381G1: 53482;
export const BLS12381G2: 53483;
export const EdDSA: 53485;
export const ES256: 13636096;
export const ES384: 13636097;
export const ES512: 13636098;
export const RS256: 13636101;
export const EIP191: 53649;
export function nameCode(name: string): 53248 | 53479 | 53482 | 53483 | 53485 | 13636096 | 13636097 | 13636098 | 13636101 | 53649;
/**
 * @template {unknown} T
 * @template {number} A
 * @implements {UCAN.SignatureView<T, A>}
 */
export class Signature<T extends unknown, A extends number> extends Uint8Array implements UCAN.SignatureView<T, A> {
    constructor(length: number);
    constructor(array: ArrayBufferLike | ArrayLike<number>);
    constructor(buffer: ArrayBufferLike, byteOffset?: number | undefined, length?: number | undefined);
    constructor(elements: Iterable<number>);
    constructor();
    get code(): A;
    get size(): number;
    get algorithm(): string;
    get raw(): Uint8Array;
    /**
     * Verify that this signature was created by the given key.
     *
     * @param {UCAN.Crypto.Verifier<A>} signer
     * @param {UCAN.ByteView<T>} payload
     */
    verify(signer: UCAN.Crypto.Verifier<A>, payload: UCAN.ByteView<T>): Promise<{
        ok: {};
        error?: undefined;
    } | {
        error: Error;
        ok?: undefined;
    }>;
    toJSON(): UCAN.SignatureJSON<Signature<T, A>>;
}
export function create<T extends unknown, A extends number>(code: A, raw: Uint8Array): UCAN.SignatureView<T, A>;
export function createNamed<T extends unknown>(name: string, raw: Uint8Array): UCAN.SignatureView<T, UCAN.SigAlg>;
export function createNonStandard<T extends unknown>(name: string, raw: Uint8Array): UCAN.SignatureView<T, 53248>;
export function view<T extends unknown, A extends number>(bytes: UCAN.ByteView<UCAN.Signature<T, A>>): UCAN.SignatureView<T, A>;
export function decode<T extends unknown, A extends number>(bytes: UCAN.ByteView<UCAN.Signature<T, A>>): UCAN.SignatureView<T, A>;
export function encode<T extends unknown, A extends number>(signature: UCAN.Signature<T, A>): UCAN.ByteView<UCAN.Signature<T, A>>;
export function format<T extends unknown, A extends number, Prefix extends string = "u">(signature: UCAN.Signature<T, A>, base?: UCAN.MultibaseEncoder<Prefix> | undefined): UCAN.ToString<UCAN.Signature<T, A>, string>;
export function parse<T extends unknown, A extends number, Prefix extends string = "u">(signature: UCAN.ToString<UCAN.Signature<T, A>, string>, base?: UCAN.MultibaseDecoder<Prefix> | undefined): UCAN.SignatureView<T, A>;
export function toJSON<Signature_1 extends UCAN.Signature<any, UCAN.SigAlg>>(signature: Signature_1): UCAN.SignatureJSON<Signature_1>;
export function fromJSON<T extends unknown, A extends UCAN.SigAlg>(json: UCAN.SignatureJSON<UCAN.Signature<T, A>>): UCAN.SignatureView<T, A>;
import * as UCAN from "./ucan.js";
//# sourceMappingURL=signature.d.ts.map