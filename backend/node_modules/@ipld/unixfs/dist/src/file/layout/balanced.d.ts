export function withWidth(width: number): Layout.LayoutEngine<Balanced>;
export namespace defaults {
    const width: number;
}
export function open({ width }?: Options): Balanced;
export function write(layout: Balanced, chunks: Chunker.Chunk[]): Layout.WriteResult<Balanced>;
export function flush(state: Balanced, leaves?: Layout.Leaf[], nodes?: Layout.Branch[] | undefined, close?: boolean | undefined): Layout.WriteResult<Balanced>;
export function close(layout: Balanced, metadata?: Layout.Metadata | undefined): Layout.CloseResult;
/**
 * Type representing a state of the balanced tree. First row hold leaves coming
 * into a builder, once number of leaves in the stack reaches `maxChildren` they
 * are moved into `RootNode` instance which is pushed into the next row of nodes.
 * If next row now contains `maxChildren` nodes from there are again moved into
 * a new `RootNode` and pushed into next row etc...
 *
 * For illustration let's assume we have `maxChildren: 3`, after 3 leafs were
 * added tree will have following layout
 *
 * ```
 *           (root1)
 *              |
 *    ----------------------
 *    |         |          |
 * (leaf1)   (leaf2)    (leaf3)
 * ```
 *
 * Which in our model before flushing is represented as follows:
 *
 * ```js
 * {
 *    width: 3
 *    leafIndex: [leaf1, leaf2, leaf3]
 *    nodeIndex: []
 *    nodes: []
 * }
 * ```
 *
 * After flushing 3 leaves (which is width) are moved into a `RootNode` that
 * is added to `nodes` array (and returned so that caller can create a block).
 * Additionally position of the added node is captured in the `index` at an
 * appropriate depth `0` (that is because we don't count leaves into depth).
 *
 * ```js
 * {
 *    width: 3
 *    leafIndex: []
 *    nodeIndex: [[0]]
 *    nodes: [new RootNode([leaf1, leaf2, leaf3])]
 * }
 * ```
 *
 * Increasing number of leaves to 10 would produce following tree layout
 *
 * ```
 *                                                         (root7)
 *                                                           |
 *                                    ------------------------------------------
 *                                    |                                        |
 *                                 (root4)                                  (root6)
 *                                    |                                        |
 *            -------------------------------------------------                |
 *            |                       |                       |                |
 *         (root1)                 (root2)                 (root3)          (root5)
 *            |                       |                       |                |
 *    --------|--------       --------|--------       --------|--------        |
 *    |       |       |       |       |       |       |       |       |        |
 * (leaf1) (leaf2) (leaf3) (leaf4) (leaf5) (leaf6) (leaf7) (leaf8) (leaf9) (leaf10)
 * ```
 *
 * Which in our model will look as follows (note we do not have root5 - root7
 * in model because they are build once width is reached or once builder is
 * closed)
 *
 * ```js
 * {
 *    width: 3
 *    leafIndex: [leaf10]
 *    nodeIndex: [
 *      [0, 1, 2], // [r1, r2, r3]
 *      [3]        // [r4]
 *     ]
 *    nodes: [
 *      new Node([leaf1, leaf2, leaf3]), // r1
 *      new Node([leaf4, leaf5, leaf6]), // r2
 *      new Node([leaf7, leaf8, leaf9]), // r3
 *      new Node([ // r4
 *         new Node([leaf1, leaf2, leaf3]), // r1
 *         new Node([leaf4, leaf5, leaf6]), // r2
 *         new Node([leaf7, leaf8, leaf9]), // r3
 *      ])
 *    ]
 * }
 * ```
 */
export type Balanced = {
    width: number;
    head: Chunker.Chunk | null;
    leafIndex: number[];
    nodeIndex: number[][];
    lastID: number;
};
export type Options = {
    /**
     * - Max children per node.
     */
    width: number;
};
import * as Layout from "./api.js";
import * as Chunker from "./../chunker/api.js";
//# sourceMappingURL=balanced.d.ts.map