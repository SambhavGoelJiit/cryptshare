export const name: "trickle";
/**
 * @typedef {{
 * maxSiblingSubgroups: number
 * maxDirectLeaves: number
 * unixfsNulLeafCompat: boolean
 * }} Options
 *
 * @type {Options}
 */
export const defaults: Options;
export function configure({ maxSiblingSubgroups, maxDirectLeaves, unixfsNulLeafCompat, }: Partial<Options>): Layout.LayoutEngine<Trickle>;
export function open(options?: Options | undefined): Trickle;
export function write(layout: Trickle, chunks: Chunker.Chunk[]): Layout.WriteResult<Trickle>;
export function addLeaf({ nodes, leaves, layout }: Layout.WriteResult<Trickle>, leaf: Layout.NodeID): Layout.WriteResult<Trickle>;
export function close(layout: Trickle, metadata?: Layout.Metadata | undefined): Layout.CloseResult;
export type Options = {
    maxSiblingSubgroups: number;
    maxDirectLeaves: number;
    unixfsNulLeafCompat: boolean;
};
export type Trickle = {
    options: Options;
    leafCount: number;
    levelCutoffs: number[];
    tail: TrickleNode;
    lastID: number;
};
import * as Layout from "./api.js";
import * as Chunker from "../chunker/api.js";
declare class TrickleNode {
    /**
     * @param {{
     * depth: number
     * directLeaves: Layout.NodeID[]
     * parent?: TrickleNode
     * }} data
     */
    constructor({ depth, directLeaves, parent }: {
        depth: number;
        directLeaves: Layout.NodeID[];
        parent?: TrickleNode;
    });
    depth: number;
    directLeaves: Layout.NodeID[];
    /** @type {TrickleNode} */
    parent: TrickleNode;
    /**
     *
     * @param {Layout.NodeID} leaf
     */
    append(leaf: Layout.NodeID): TrickleNode;
}
export {};
//# sourceMappingURL=trickle.d.ts.map