export * from "./rsa/type.js";
export const name: "RSA";
/** @type {API.RSASigner['code']} */
export const code: API.RSASigner['code'];
/** @type {API.SigAlg} */
export const signatureCode: API.SigAlg;
export const signatureAlgorithm: "RS256";
export function generate({ size, extractable, }?: {
    size?: number | undefined;
    extractable?: boolean | undefined;
}): Promise<API.RSASigner>;
export function from({ id, keys }: API.SignerArchive<API.DID, typeof signatureCode>): API.RSASigner;
export function or<Other extends API.SignerImporter<`did:${string}:${string}`, API.Crypto.SigAlg>>(other: Other): API.CompositeImporter<[{
    from: ({ id, keys }: API.SignerArchive<API.DID, typeof signatureCode>) => API.RSASigner;
}, Other]>;
export function decode(bytes: EncodedSigner): API.RSASigner;
export { RSAVerifier as Verifier };
export type EncodedSigner = API.ByteView<API.Signer<API.DID<'key'>, typeof signatureCode> & CryptoKey>;
import * as API from './rsa/type.js';
/**
 * @typedef {API.ByteView<API.Signer<API.DID<'key'>, typeof signatureCode> & CryptoKey>} EncodedSigner
 */
declare class RSASigner {
    /**
     * @param {object} options
     * @param {API.Await<CryptoKey>} options.privateKey
     * @param {API.RSAVerifier} options.verifier
     */
    constructor({ privateKey, verifier }: {
        privateKey: API.Await<CryptoKey>;
        verifier: API.RSAVerifier;
    });
    /** @readonly */
    readonly verifier: API.RSAVerifier;
    /** @protected */
    protected privateKey: API.Await<CryptoKey>;
    get signer(): RSASigner;
    /**
     * @type {typeof code}
     */
    get code(): API.MulticodecCode<4869, "RSAPrivateKey">;
    /**
     * @type {typeof signatureCode}
     */
    get signatureCode(): API.SigAlg;
    /**
     * @type {typeof signatureAlgorithm}
     */
    get signatureAlgorithm(): "RS256";
    did(): `did:key:${string}`;
    toDIDKey(): `did:key:${string}`;
    /**
     * @template T
     * @param {API.ByteView<T>} payload
     * @param {API.Signature<T, typeof this.signatureCode>} signature
     */
    verify<T>(payload: API.ByteView<T>, signature: API.Signature<T, API.SigAlg>): API.Crypto.Await<boolean>;
    /**
     * @template T
     * @param {API.ByteView<T>} payload
     * @returns {Promise<API.SignatureView<T, typeof signatureCode>>}
     */
    sign<T_1>(payload: API.ByteView<T_1>): Promise<API.SignatureView<T_1, API.SigAlg>>;
}
import * as DID from '@ipld/dag-ucan/did';
/**
 * @implements {API.RSAVerifier}
 */
declare class RSAVerifier implements API.RSAVerifier {
    /**
     * @param {API.ByteView<API.RSAVerifier>} bytes
     * @returns {API.RSAVerifier}
     */
    static decode(bytes: API.ByteView<API.RSAVerifier>): API.RSAVerifier;
    /**
     * @param {API.DIDKey} did
     * @returns {API.RSAVerifier}
     */
    static parse(did: API.DIDKey): API.RSAVerifier;
    /**
     * @param {API.PrincipalParser} other
     */
    static or(other: API.PrincipalParser): API.ComposedDIDParser;
    /**
     * @param {object} options
     * @param {API.Await<CryptoKey>} options.publicKey
     * @param {API.ByteView<API.RSAVerifier>} options.bytes
     */
    constructor({ publicKey, bytes }: {
        publicKey: API.Await<CryptoKey>;
        bytes: API.ByteView<API.RSAVerifier>;
    });
    /** @private */
    private publicKey;
    /** @private */
    private bytes;
    /**
     * @template {API.DID} ID
     * @param {ID} id
     * @returns {API.Verifier<ID, typeof signatureCode>}
     */
    withDID<ID extends `did:${string}:${string}`>(id: ID): API.Verifier<ID, API.SigAlg>;
    toDIDKey(): `did:key:${string}`;
    /** @type {typeof verifierCode} */
    get code(): API.MulticodecCode<4613, "RSAPublicKey">;
    /**
     * @type {typeof signatureCode}
     */
    get signatureCode(): API.SigAlg;
    /**
     * @type {typeof signatureAlgorithm}
     */
    get signatureAlgorithm(): "RS256";
    /**
     * DID of the Principal in `did:key` format.
     * @returns {API.DID<"key">}
     */
    did(): API.DID<"key">;
    /**
     * @template T
     * @param {API.ByteView<T>} payload
     * @param {API.Signature<T, typeof this.signatureCode>} signature
     * @returns {Promise<boolean>}
     */
    verify<T>(payload: API.ByteView<T>, signature: API.Signature<T, API.SigAlg>): Promise<boolean>;
}
import * as Signer from './signer.js';
//# sourceMappingURL=rsa.d.ts.map