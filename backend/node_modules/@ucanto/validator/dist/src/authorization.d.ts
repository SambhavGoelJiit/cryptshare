export function create<C extends API.ParsedCapability<API.Ability, API.URI, any>>(match: API.Match<C, API.UnknownMatch>, proofs?: API.Authorization<API.ParsedCapability>[]): API.Authorization<C>;
export function iterate({ delegation, proofs }: API.Authorization): Iterable<API.UCANLink>;
import * as API from '@ucanto/interface';
/**
 * @template {API.ParsedCapability} C
 * @implements {API.Authorization<C>}
 */
declare class Authorization<C extends API.ParsedCapability<API.Ability, API.URI, any>> implements API.Authorization<C> {
    /**
     * @param {API.Match<C>} match
     * @param {API.Authorization<API.ParsedCapability>[]} proofs
     */
    constructor(match: API.Match<C>, proofs: API.Authorization<API.ParsedCapability>[]);
    match: API.Match<C, API.UnknownMatch>;
    proofs: API.Authorization<API.ParsedCapability<API.Ability, API.URI, any>>[];
    get capability(): C;
    get delegation(): API.Delegation<API.Capabilities>;
    get issuer(): API.Principal<`did:${string}:${string}`>;
    get audience(): API.Principal<`did:${string}:${string}`>;
}
export {};
//# sourceMappingURL=authorization.d.ts.map