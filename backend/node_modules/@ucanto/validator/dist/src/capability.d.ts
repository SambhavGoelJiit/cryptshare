export function capability<A extends API.Ability, R extends API.URI<`${string}:`>, C extends API.Caveats = {}>({ derives, nb, ...etc }: Descriptor<A, R, C>): API.TheCapabilityParser<API.CapabilityMatch<A, R, C>>;
export function or<M extends API.Match<any, API.UnknownMatch>, W extends API.Match<any, API.UnknownMatch>>(left: API.Matcher<M>, right: API.Matcher<W>): API.CapabilityParser<M | W>;
export function and<Selectors extends API.MatchSelector<API.Match<any, API.UnknownMatch>>[]>(...selectors: Selectors): API.CapabilitiesParser<API.InferMembers<Selectors>>;
export function derive<M extends API.Match<any, API.UnknownMatch>, T extends API.ParsedCapability<API.Ability, API.URI, any>>({ from, to, derives }: {
    from: API.MatchSelector<M>;
    to: API.TheCapabilityParser<API.DirectMatch<T>>;
    derives: API.Derives<T, API.InferDeriveProof<M["value"]>>;
}): API.TheCapabilityParser<API.DerivedMatch<T, M>>;
export type Descriptor<A extends API.Ability, R extends API.URI<`${string}:`>, C extends API.Caveats> = {
    can: A;
    with: API.Reader<R, API.Resource, API.Failure>;
    nb?: Schema.MapRepresentation<C, unknown> | undefined;
    derives?: ((claim: {
        can: A;
        with: R;
        nb: C;
    }, proof: {
        can: A;
        with: R;
        nb: C;
    }) => API.Result<{}, API.Failure>) | undefined;
};
import * as API from '@ucanto/interface';
/**
 * @template {API.ParsedCapability} T
 * @template {API.Match} M
 * @implements {API.DerivedMatch<T, M>}
 */
declare class DerivedMatch<T extends API.ParsedCapability<API.Ability, API.URI, any>, M extends API.Match<any, API.UnknownMatch>> implements API.DerivedMatch<T, M> {
    /**
     * @param {API.DirectMatch<T>} selected
     * @param {API.MatchSelector<M>} from
     * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives
     */
    constructor(selected: API.DirectMatch<T>, from: API.MatchSelector<M>, derives: API.Derives<T, API.InferDeriveProof<M['value']>>);
    selected: API.DirectMatch<T>;
    from: API.MatchSelector<M>;
    derives: API.Derives<T, API.InferDeriveProof<M["value"]>>;
    get can(): API.Ability;
    get source(): API.Source[];
    get proofs(): API.Delegation<API.Capabilities>[];
    get value(): T;
    /**
     * @param {API.CanIssue} context
     */
    prune(context: API.CanIssue): DerivedMatch<T, M> | null;
    /**
     * @param {API.Source[]} capabilities
     */
    select(capabilities: API.Source[]): {
        unknown: API.Capability<API.Ability, `${string}:${string}`, unknown>[];
        errors: (API.DelegationError | MatchError)[];
        matches: (DerivedMatch<T, M> | M)[];
    };
    toString(): string;
}
import { Schema } from '@ucanto/core';
import { DelegationError as MatchError } from './error.js';
export {};
//# sourceMappingURL=capability.d.ts.map