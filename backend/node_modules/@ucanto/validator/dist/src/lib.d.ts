export { capability } from "./capability.js";
export * from "@ucanto/core/schema";
export function access<A extends API.Ability, R extends API.URI<`${string}:`>, URI extends R, C extends API.Caveats>(invocation: API.Invocation<API.Capability<A, URI, C>>, { capability, ...config }: API.ValidationOptions<API.ParsedCapability<A, R, C>>): Promise<API.Result<API.Authorization<API.ParsedCapability<A, R, C>>, API.Unauthorized>>;
export function claim<A extends API.Ability, R extends API.URI<`${string}:`>, C extends API.Caveats>(capability: API.CapabilityParser<API.Match<API.ParsedCapability<A, R, C>, API.UnknownMatch>>, proofs: API.Proof[], { authority, principal, validateAuthorization, resolveDIDKey, canIssue, resolve, }: API.ClaimOptions): Promise<API.Result<API.Authorization<API.ParsedCapability<A, R, C>>, API.Unauthorized>>;
export function authorize<Match extends API.Match<any, API.UnknownMatch>>(match: Match, config: Required<API.ClaimOptions>): Promise<API.Result<API.Authorization<API.ParsedCapability>, API.InvalidClaim>>;
import * as Schema from '@ucanto/core/schema';
import * as Authorization from './authorization.js';
import { Failure } from './error.js';
import { fail } from '@ucanto/core';
import { ok } from '@ucanto/core';
import { Revoked } from './error.js';
import { UnavailableProof } from './error.js';
import { Unauthorized } from './error.js';
import { MalformedCapability } from './error.js';
import { DIDKeyResolutionError } from './error.js';
import * as API from '@ucanto/interface';
/**
 * @implements {API.InvalidClaim}
 */
declare class InvalidClaim extends Failure implements API.InvalidClaim {
    /**
     * @param {{
     * match: API.Match
     * delegationErrors: API.DelegationError[]
     * unknownCapabilities: API.Capability[]
     * invalidProofs: ProofError[]
     * failedProofs: API.InvalidClaim[]
     * }} info
     */
    constructor(info: {
        match: API.Match;
        delegationErrors: API.DelegationError[];
        unknownCapabilities: API.Capability[];
        invalidProofs: ProofError[];
        failedProofs: API.InvalidClaim[];
    });
    info: {
        match: API.Match;
        delegationErrors: API.DelegationError[];
        unknownCapabilities: API.Capability[];
        invalidProofs: ProofError[];
        failedProofs: API.InvalidClaim[];
    };
    /** @type {"InvalidClaim"} */
    name: "InvalidClaim";
    get issuer(): API.Principal<`did:${string}:${string}`>;
    get delegation(): API.Delegation<API.Capabilities>;
}
import { DelegationError } from './error.js';
declare class ProofError extends Failure {
    /**
     * @param {API.UCANLink} proof
     * @param {API.Failure} cause
     */
    constructor(proof: API.UCANLink, cause: API.Failure);
    proof: API.UCANLink<API.Capabilities, API.MulticodecCode<number, string>, API.SigAlg>;
    cause: API.Failure;
}
export { Schema, Authorization, Failure, fail, ok, Revoked, UnavailableProof, Unauthorized, MalformedCapability, DIDKeyResolutionError as DIDResolutionError };
//# sourceMappingURL=lib.d.ts.map