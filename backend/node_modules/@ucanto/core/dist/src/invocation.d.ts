export function isInvocation(value: API.Invocation | API.Link): value is API.Invocation<API.Capability<API.Ability, `${string}:${string}`, unknown>>;
export function invoke<Capability extends API.Capability<API.Ability, `${string}:${string}`, any>>(options: API.InvocationOptions<Capability>): API.IssuedInvocationView<Capability>;
export function create<C extends API.Capability<API.Ability, `${string}:${string}`, any>>({ root, blocks }: {
    root: API.UCANBlock<[C], API.MulticodecCode<number, string>, API.SigAlg>;
    blocks?: DAG.BlockStore<unknown> | undefined;
}): API.Invocation<C>;
export function view<C extends API.Capability<API.Ability, `${string}:${string}`, any>, Invocation_1 extends API.Invocation<API.Capability<API.Ability, `${string}:${string}`, unknown>>, T = never>({ root, blocks }: {
    root: API.UCANLink<[C], API.MulticodecCode<number, string>, API.SigAlg>;
    blocks: DAG.BlockStore<unknown>;
}, fallback?: T | undefined): T | API.Invocation<C>;
/**
 * @template {API.Capability} Capability
 * @implements {API.Invocation<Capability>}
 * @extends {Delegation<[Capability]>}
 */
export class Invocation<Capability extends API.Capability<API.Ability, `${string}:${string}`, any>> extends Delegation<[Capability]> implements API.Invocation<Capability> {
    constructor(root: API.UCANBlock<[Capability], API.MulticodecCode<number, string>, API.SigAlg>, blocks?: DAG.BlockStore<unknown> | undefined);
}
import * as API from '@ucanto/interface';
import * as DAG from './dag.js';
import { Delegation } from './delegation.js';
//# sourceMappingURL=invocation.d.ts.map