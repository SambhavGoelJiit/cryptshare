export * from "./type.js";
/**
 * @abstract
 * @template [T=unknown]
 * @template [I=unknown]
 * @template [Settings=void]
 * @extends {Schema.Base<T, I, Settings>}
 * @implements {Schema.Schema<T, I>}
 */
export class API<T = unknown, I = unknown, Settings = void> implements Schema.Schema<T, I> {
    /**
     * @param {Settings} settings
     */
    constructor(settings: Settings);
    /** @protected */
    protected settings: Settings;
    toString(): string;
    /**
     * @abstract
     * @param {I} input
     * @param {Settings} settings
     * @returns {Schema.ReadResult<T>}
     */
    readWith(input: I, settings: Settings): Schema.ReadResult<T>;
    /**
     * @param {I} input
     * @returns {Schema.ReadResult<T>}
     */
    read(input: I): Schema.ReadResult<T>;
    /**
     * @param {unknown} value
     * @returns {value is T}
     */
    is(value: unknown): value is T;
    /**
     * @param {unknown} value
     * @return {T}
     */
    from(value: unknown): T;
    /**
     * @returns {Schema.Schema<T|undefined, I>}
     */
    optional(): Schema.Schema<T | undefined, I>;
    /**
     * @returns {Schema.Schema<T|null, I>}
     */
    nullable(): Schema.Schema<T | null, I>;
    /**
     * @returns {Schema.Schema<T[], I>}
     */
    array(): Schema.Schema<T[], I>;
    /**
     * @template U
     * @param {Schema.Reader<U, I>} schema
     * @returns {Schema.Schema<T | U, I>}
     */
    or<U>(schema: Schema.Reader<U, I, Schema.Error>): Schema.Schema<T | U, I>;
    /**
     * @template U
     * @param {Schema.Reader<U, I>} schema
     * @returns {Schema.Schema<T & U, I>}
     */
    and<U_1>(schema: Schema.Reader<U_1, I, Schema.Error>): Schema.Schema<T & U_1, I>;
    /**
     * @template {T} U
     * @param {Schema.Reader<U, T>} schema
     * @returns {Schema.Schema<U, I>}
     */
    refine<U_2 extends T>(schema: Schema.Reader<U_2, T, Schema.Error>): Schema.Schema<U_2, I>;
    /**
     * @template {string} Kind
     * @param {Kind} [kind]
     * @returns {Schema.Schema<Schema.Branded<T, Kind>, I>}
     */
    brand<Kind extends string>(kind?: Kind | undefined): Schema.Schema<Schema.Branded<T, Kind>, I>;
    /**
     * @param {Schema.NotUndefined<T>} value
     * @returns {Schema.DefaultSchema<Schema.NotUndefined<T>, I>}
     */
    default(value: Schema.NotUndefined<T>): Schema.DefaultSchema<Schema.NotUndefined<T>, I>;
}
export function never<I = unknown>(): Schema.Schema<never, I>;
export function unknown<I = unknown>(): Schema.Schema<unknown, I>;
export function nullable<O, I = unknown>(schema: Schema.Reader<O, I, Schema.Error>): Schema.Schema<O | null, I>;
export function optional<O, I = unknown>(schema: Schema.Reader<O, I, Schema.Error>): Schema.Schema<O | undefined, I>;
export function array<O, I = unknown>(schema: Schema.Reader<O, I, Schema.Error>): Schema.ArraySchema<O, I>;
export function tuple<T extends Schema.Reader<unknown, I, Schema.Error>, U extends [T, ...T[]], I = unknown>(shape: U): Schema.Schema<Schema.InferTuple<U>, I>;
export function dictionary<K extends string, V extends unknown, I = unknown>({ value, key }: {
    value: Schema.Reader<V, I, Schema.Error>;
    key?: Schema.Reader<K, string, Schema.Error> | undefined;
}): Schema.DictionarySchema<V, K, I>;
export function or<T, U, I = unknown>(left: Schema.Reader<T, I, Schema.Error>, right: Schema.Reader<U, I, Schema.Error>): Schema.Schema<T | U, I>;
export function intersection<T extends Schema.Reader<unknown, I, Schema.Error>, U extends [T, ...T[]], I = unknown>(variants: U): Schema.Schema<Schema.InferIntersection<U>, I>;
export function and<T, U, I = unknown>(left: Schema.Reader<T, I, Schema.Error>, right: Schema.Reader<U, I, Schema.Error>): Schema.Schema<T & U, I>;
export function boolean(): Schema.Schema<boolean, unknown>;
export function number(): Schema.NumberSchema<number, unknown>;
export function lessThan<T extends number>(n: number): Schema.Schema<T, T>;
export function greaterThan<T extends number>(n: number): Schema.Schema<T, T>;
export function integer(): Schema.NumberSchema<number & import("multiformats").Phantom<{
    typeof: "integer";
}>, unknown>;
export function uint64(): Schema.Schema<Schema.Uint64, unknown>;
export function float(): Schema.NumberSchema<number & import("multiformats").Phantom<{
    typeof: "float";
}>, unknown>;
export function string(): Schema.StringSchema<string, unknown>;
/** @type {Schema.Schema<Uint8Array, unknown>} */
export const Bytes: Schema.Schema<Uint8Array, unknown>;
export function bytes(): Schema.Schema<Uint8Array, unknown>;
export function startsWith<Prefix extends string, Body_1 extends string>(prefix: Prefix): Schema.Schema<`${Prefix}${string}`, string>;
export function endsWith<Suffix extends string>(suffix: Suffix): Schema.Schema<`${string}${Suffix}`, string>;
export function refine<T, U extends T, I = unknown>(base: Schema.Reader<T, I, Schema.Error>, schema: Schema.Reader<U, T, Schema.Error>): Schema.Schema<U, I>;
export function literal<T extends string | number | boolean | null, I = unknown>(value: T): Schema.LiteralSchema<T, I>;
export function struct<T extends string | number | boolean | null, U extends {
    [key: string]: Schema.Reader<any, any, Schema.Error> | T;
}, V extends { [K in keyof U]: U[K] extends Schema.Reader<any, any, Schema.Error> ? U[K] : Schema.LiteralSchema<U[K] & T, any>; }, I = unknown>(fields: U): Schema.StructSchema<V, I>;
export function variant<Choices extends Schema.VariantChoices, In = unknown>(variants: Choices): Schema.VariantSchema<Choices, In>;
export function error(message: string): {
    error: Schema.Error;
    ok?: undefined;
};
export function typeError(data: {
    expect: string;
    actual: unknown;
}): {
    error: Schema.Error;
};
export function toString(value: unknown): unknown;
export function memberError({ at, cause }: {
    at: string | number;
    cause: Schema.Error;
}): {
    error: Schema.Error;
};
import { ok } from '../result.js';
import * as Schema from './type.js';
/**
 * @template {string} T
 * @template {[T, ...T[]]} U
 * @template [I=unknown]
 * @param {U} variants
 * @returns {Schema.Schema<U[number], I>}
 */
declare function createEnum<T extends string, U extends [T, ...T[]], I = unknown>(variants: U): Schema.Schema<U[number], I>;
export { ok, createEnum as enum, _enum as enum };
//# sourceMappingURL=schema.d.ts.map