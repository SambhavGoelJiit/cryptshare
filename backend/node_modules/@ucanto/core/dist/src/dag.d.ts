export function iterate(value: unknown): IterableIterator<API.Block>;
export function createStore<T = unknown>(blocks?: API.Transport.Block<T, number, number, 1>[]): API.BlockStore<T>;
export function get<V extends 0 | 1, U extends T, T, Format extends API.MulticodecCode, Alg extends API.MulticodecCode, E = never>(cid: API.Link<U, Format, Alg, V>, store: BlockStore<T>, fallback?: E | undefined): E | API.Transport.Block<U, Format, Alg, V>;
export function embed<T, U extends T, C extends API.MulticodecCode = API.MulticodecCode<113, "dag-cbor">>(source: U, { codec }?: {
    codec?: MF.BlockEncoder<C, U> | undefined;
}): API.Transport.Block<U, C, API.MulticodecCode<0, "identity">, 1> & {
    data: U;
};
export function notFound(link: API.Link<any, any, any, any>): never;
export function writeInto<T, U extends T, C extends API.MulticodecCode, A extends API.MulticodecCode>(source: U, store: BlockStore<T>, options?: {
    codec?: MF.BlockEncoder<C, unknown> | undefined;
    hasher?: API.MultihashHasher<A> | undefined;
}): Promise<API.Transport.Block<U, C, A, 1> & {
    data: U;
}>;
export function addInto<T, U extends T>({ cid, bytes }: API.Transport.Block<U, number, number, 1>, store: BlockStore<T>): API.Transport.Block<U, number, number, 1>;
export function addEveryInto<T, U extends T>(source: Iterable<API.Transport.Block<U, number, number, 1>>, store: BlockStore<T>): void;
export type BlockStore<T = unknown> = Map<API.ToString<API.Link>, API.Block<T, number, number, 0> | API.Block<T, number, number, 1>>;
import * as CBOR from './cbor.js';
import { sha256 } from 'multiformats/hashes/sha2';
import { identity } from 'multiformats/hashes/identity';
import * as API from '@ucanto/interface';
import * as MF from 'multiformats/interface';
/** @type {API.MulticodecCode<typeof identity.code, typeof identity.name>} */
declare const EMBED_CODE: API.MulticodecCode<typeof identity.code, typeof identity.name>;
export { CBOR, sha256, identity };
//# sourceMappingURL=dag.d.ts.map