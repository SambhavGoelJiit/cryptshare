export function isLink(value: API.Proof): value is UCAN.Link<UCAN.Capabilities, UCAN.MulticodecCode<number, string>, UCAN.SigAlg>;
export function isDelegation(proof: API.Proof): proof is API.Delegation<UCAN.Capabilities>;
export function allows<T extends [API.Delegation<UCAN.Capabilities>, ...API.Delegation<UCAN.Capabilities>[]]>(...delegations: T): API.InferAllowedFromDelegations<T>;
/**
 * Represents UCAN chain view over the set of DAG UCAN nodes. You can think of
 * this as UCAN interface of the CAR.
 *
 * @template {API.Capabilities} C
 * @implements {API.Delegation<C>}
 * @extends {DelegationView<C>}
 */
export class Delegation<C extends UCAN.Capabilities> implements API.Delegation<C> {
    /**
     * @param {API.UCANBlock<C>} root
     * @param {DAG.BlockStore} [blocks]
     */
    constructor(root: API.UCANBlock<C>, blocks?: DAG.BlockStore<unknown> | undefined);
    root: UCAN.Block<C, UCAN.MulticodecCode<number, string>, UCAN.SigAlg>;
    blocks: DAG.BlockStore<unknown>;
    /**
     * @returns {API.AttachedLinkSet}
     */
    get attachedLinks(): API.AttachedLinkSet;
    get version(): `${number}.${number}.${number}`;
    get signature(): UCAN.SignatureView<unknown, UCAN.SigAlg>;
    get cid(): UCAN.IPLDLink<UCAN.UCAN<C>, UCAN.MulticodecCode<number, string>, UCAN.SigAlg, 1>;
    link(): UCAN.IPLDLink<UCAN.UCAN<C>, UCAN.MulticodecCode<number, string>, UCAN.SigAlg, 1>;
    get asCID(): UCAN.IPLDLink<UCAN.UCAN<C>, UCAN.MulticodecCode<number, string>, UCAN.SigAlg, 1>;
    get bytes(): UCAN.ByteView<UCAN.UCAN<C>>;
    get data(): UCAN.View<C>;
    /**
     * Attach a block to the delegation DAG so it would be included in the
     * block iterator.
     * ⚠️ You can only attach blocks that are referenced from the `capabilities`
     * or `facts`.
     *
     * @param {API.Block} block
     */
    attach(block: API.Block): void;
    export(): IterableIterator<API.Transport.Block<any, number, number, 1>>;
    /**
     * @returns {API.Await<API.Result<Uint8Array, Error>>}
     */
    archive(): API.Await<API.Result<Uint8Array, Error>>;
    iterateIPLDBlocks(): IterableIterator<API.Transport.Block<any, number, number, 1>>;
    /**
     * @type {API.Proof[]}
     */
    get proofs(): API.Proof<UCAN.Capabilities>[];
    /**
     * @type {API.Principal}
     */
    get issuer(): UCAN.Principal<`did:${string}:${string}`>;
    /**
     * @type {API.Principal}
     */
    get audience(): UCAN.Principal<`did:${string}:${string}`>;
    /**
     * @returns {C}
     */
    get capabilities(): C;
    /**
     * @returns {number}
     */
    get expiration(): number;
    /**
     * @returns {undefined|number}
     */
    get notBefore(): number | undefined;
    /**
     * @returns {undefined|string}
     */
    get nonce(): string | undefined;
    /**
     * @returns {API.Fact[]}
     */
    get facts(): UCAN.Fact[];
    /**
     * Iterate over the proofs
     *
     * @returns {IterableIterator<API.Delegation>}
     */
    iterate(): IterableIterator<API.Delegation>;
    delegate(): Delegation<C>;
    buildIPLDView(): Delegation<C>;
    /**
     * @returns {API.DelegationJSON<this>}
     */
    toJSON(): API.DelegationJSON<Delegation<C>>;
}
export function archive(delegation: API.Delegation): Promise<API.Result<Uint8Array, Error>>;
export const ArchiveSchema: Schema.VariantSchema<{
    'ucan@0.9.1': Schema.Schema<UCAN.Link<UCAN.Capabilities, UCAN.MulticodecCode<number, string>, UCAN.SigAlg>, any>;
}, unknown>;
export function extract(archive: Uint8Array): Promise<{
    error: API.Failure;
    ok?: undefined;
} | {
    ok: API.Delegation<UCAN.Capabilities>;
    error?: undefined;
}>;
export function delegate<C extends UCAN.Capabilities>({ issuer, audience, proofs, attachedBlocks, ...input }: API.DelegationOptions<C>, options?: API.EncodeOptions | undefined): Promise<API.Delegation<C>>;
export function exportDAG<C extends UCAN.Capabilities>(root: UCAN.Block<C, UCAN.MulticodecCode<number, string>, UCAN.SigAlg>, blocks: DAG.BlockStore<unknown>, attachedLinks: API.AttachedLinkSet): IterableIterator<API.Block>;
export function importDAG<C extends UCAN.Capabilities>(dag: Iterable<API.Block>): API.Delegation<C>;
export function create<C extends UCAN.Capabilities>({ root, blocks }: {
    root: UCAN.Block<C, UCAN.MulticodecCode<number, string>, UCAN.SigAlg>;
    blocks?: DAG.BlockStore<unknown> | undefined;
}): API.Delegation<C>;
export function view<C extends UCAN.Capabilities, E = never>({ root, blocks }: {
    root: UCAN.Link<C, UCAN.MulticodecCode<number, string>, UCAN.SigAlg>;
    blocks: DAG.BlockStore<unknown>;
}, fallback?: E | undefined): E | API.Delegation<C>;
export { Delegation as View };
import * as API from '@ucanto/interface';
import * as UCAN from '@ipld/dag-ucan';
import * as DAG from './dag.js';
import * as Schema from './schema.js';
//# sourceMappingURL=delegation.d.ts.map