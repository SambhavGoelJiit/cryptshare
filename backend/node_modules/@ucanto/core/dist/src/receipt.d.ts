export function view<Ok extends {}, Error_1 extends {}, Ran extends API.Invocation<API.Capability<API.Ability, `${string}:${string}`, unknown>>, E = never>({ root, blocks }: {
    root: API.Link<API.ReceiptModel<Ok, Error_1, Ran>, number, number, 1>;
    blocks: DAG.BlockStore<unknown>;
}, fallback?: E | undefined): (E & ({} | null)) | Receipt<Ok, Error_1, Ran, API.SigAlg>;
export function issue<Ok extends {}, Error_1 extends {}, Ran extends API.Invocation<API.Capability<API.Ability, `${string}:${string}`, unknown>>, SigAlg extends API.SigAlg>(options: {
    issuer: API.Signer<`did:${string}:${string}`, SigAlg>;
    ran: Ran | ReturnType<Ran["link"]>;
    result: API.Result<Ok, Error_1>;
    fx?: API.Effects | undefined;
    proofs?: API.Proof<API.Capabilities>[] | undefined;
    meta?: Record<string, unknown> | undefined;
}): Promise<API.Receipt<Ok, Error_1, Ran, SigAlg>>;
import * as API from '@ucanto/interface';
import * as DAG from './dag.js';
/**
 * Represents a UCAN invocation receipt view over some block store e.g. in
 * memory CAR. It incrementally decodes proofs, ran invocation etc. on access
 * which reduces overhead but potentially defers errors if references blocks
 * do not conform to the expected IPLD schema.
 *
 * @template {{}} Ok
 * @template {{}} Error
 * @template {API.Invocation} Ran
 * @template {API.SigAlg} [SigAlg=API.SigAlg]
 * @implements {API.Receipt<Ok, Error, Ran, SigAlg>}
 */
declare class Receipt<Ok extends {}, Error extends {}, Ran extends API.Invocation<API.Capability<API.Ability, `${string}:${string}`, unknown>>, SigAlg extends API.SigAlg = API.SigAlg> implements API.Receipt<Ok, Error, Ran, SigAlg> {
    /**
     * @param {object} input
     * @param {Required<API.Block<API.ReceiptModel<Ok, Error, Ran>>>} input.root
     * @param {DAG.BlockStore} input.store
     * @param {API.Meta} [input.meta]
     * @param {Ran|ReturnType<Ran['link']>} [input.ran]
     * @param {API.EffectsModel} [input.fx]
     * @param {API.SignatureView<API.OutcomeModel<Ok, Error, Ran>, SigAlg>} [input.signature]
     * @param {API.UCAN.Principal} [input.issuer]
     * @param {API.Proof[]} [input.proofs]
     */
    constructor({ root, store, ran, issuer, signature, proofs }: {
        root: Required<API.Block<API.ReceiptModel<Ok, Error, Ran>>>;
        store: DAG.BlockStore<unknown>;
        meta?: API.Meta | undefined;
        ran?: Ran | ReturnType<Ran["link"]> | undefined;
        fx?: API.EffectsModel | undefined;
        signature?: API.SignatureView<API.OutcomeModel<Ok, Error, Ran>, SigAlg> | undefined;
        issuer?: API.Principal<`did:${string}:${string}`> | undefined;
        proofs?: API.Proof<API.Capabilities>[] | undefined;
    });
    store: DAG.BlockStore<unknown>;
    root: Required<API.Transport.Block<API.ReceiptModel<Ok, Error, Ran>, number, number, 1>>;
    _ran: Ran | ReturnType<Ran["link"]> | undefined;
    /** @type {API.Effects|undefined} */
    _fx: API.Effects | undefined;
    _signature: API.SignatureView<API.OutcomeModel<Ok, Error, Ran>, SigAlg> | undefined;
    _proofs: API.Proof<API.Capabilities>[] | undefined;
    _issuer: API.Principal<`did:${string}:${string}`> | undefined;
    /**
     * @returns {Ran|ReturnType<Ran['link']>}
     */
    get ran(): Ran | ReturnType<Ran["link"]>;
    get proofs(): API.Proof<API.Capabilities>[];
    link(): API.Link<API.ReceiptModel<Ok, Error, Ran>, number, number, 1>;
    get meta(): API.Meta;
    get issuer(): API.Principal<`did:${string}:${string}`> | undefined;
    get out(): API.Result<Ok, Error>;
    get fx(): API.Effects;
    get signature(): API.SignatureView<API.OutcomeModel<Ok, Error, Ran>, SigAlg>;
    /**
     * @param {API.Crypto.Verifier} signingPrincipal
     */
    verifySignature(signingPrincipal: API.Crypto.Verifier): API.Crypto.Await<{
        ok: {};
        error?: undefined;
    } | {
        error: globalThis.Error;
        ok?: undefined;
    }>;
    buildIPLDView(): Receipt<Ok, Error, Ran, SigAlg>;
    iterateIPLDBlocks(): Generator<API.Transport.Block<any, number, number, 1>, void, undefined>;
}
import * as DID from '@ipld/dag-ucan/did';
export {};
//# sourceMappingURL=receipt.d.ts.map