export const contentType: "application/vnd.ipld.car";
export const name: "CAR";
/** @type {API.MulticodecCode<0x0202, 'CAR'>} */
export const code: API.MulticodecCode<0x0202, 'CAR'>;
export function createWriter(): Writer;
export function encode<T extends Partial<Model>>({ roots, blocks }: T): API.ByteView<T>;
export function decode(bytes: API.ByteView<Partial<Model>>): Model;
export function link<T extends Partial<Model>>(bytes: API.ByteView<T>, { hasher }?: {
    hasher?: API.MultihashHasher;
}): Promise<API.Link<T, API.MulticodecCode<514, "CAR">, number, 1>>;
export function write<T extends Partial<Model>>(data: T, options?: {
    hasher?: API.MultihashHasher<number> | undefined;
} | undefined): Promise<API.Transport.Block<T, API.MulticodecCode<514, "CAR">, number, 1>>;
export type Model = {
    roots: API.IPLDBlock[];
    blocks: Map<string, API.IPLDBlock>;
};
import * as API from '@ucanto/interface';
/**
 * @typedef {{
 * roots: API.IPLDBlock[]
 * blocks: Map<string, API.IPLDBlock>
 * }} Model
 */
declare class Writer {
    /**
     * @param {API.IPLDBlock[]} blocks
     * @param {number} byteLength
     */
    constructor(blocks?: API.IPLDBlock[], byteLength?: number);
    written: Set<any>;
    blocks: API.IPLDBlock<any, number, number, 1>[];
    byteLength: number;
    /**
     * @param {API.IPLDBlock[]} blocks
     */
    write(...blocks: API.IPLDBlock[]): Writer;
    /**
     * @param {API.IPLDBlock[]} rootBlocks
     */
    flush(...rootBlocks: API.IPLDBlock[]): Uint8Array;
}
export {};
//# sourceMappingURL=car.d.ts.map