/**
 * @see https://github.com/multiformats/multicodec/pull/331/files
 */
export const name: "fr32-sha2-256-trunc254-padded-binary-tree";
/**
 * @type {API.MulticodecCode<0x1011, typeof name>}
 * @see https://github.com/multiformats/multicodec/pull/331/files
 */
export const code: API.MulticodecCode<0x1011, typeof name>;
/**
 * The digest for the multihash is 33 bytes. The first byte defines the height
 * of the tree and the remaining 32 bytes are the sha-256 digest of the root
 * node.
 *
 * @type {33}
 */
export const size: 33;
/**
 * Since first byte in the digest is the tree height, the maximum height is 255.
 *
 * @type {255}
 */
export const MAX_HEIGHT: 255;
/**
 * Max payload is determined by the maximum height of the tree, which is limited
 * by the int we could store in one byte. We calculate the max piece size
 * and derive max payload size that can would produce it after FR32 padding.
 */
export const MAX_PAYLOAD_SIZE: bigint;
export function digest(payload: Uint8Array): API.PieceDigest;
export function create(): API.StreamingHasher<typeof code, typeof size, API.PieceDigest>;
/**
 * Byte encoded {@link code} and the {@link size} of the digest.
 */
export const PREFIX: Uint8Array;
export function toDigest({ height, root }: API.Piece): API.PieceDigest;
export function createDigest(): Digest;
export type Layers = [API.MerkleTreeNode[], ...API.MerkleTreeNode[][]];
import * as API from './api.js';
import * as Piece from './piece.js';
declare class Digest {
    /**
     * @param {Uint8Array} bytes
     */
    constructor(bytes: Uint8Array);
    bytes: Uint8Array;
    digest: Uint8Array;
    root: Uint8Array;
    get height(): number;
    get size(): 33;
    get name(): "fr32-sha2-256-trunc254-padded-binary-tree";
    get code(): API.MulticodecCode<4113, "fr32-sha2-256-trunc254-padded-binary-tree">;
}
export {};
//# sourceMappingURL=multihash.d.ts.map