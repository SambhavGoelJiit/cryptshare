export * as Access from "./capability/access.js";
export class Client extends Base {
    capability: {
        access: AccessClient;
        filecoin: FilecoinClient;
        space: SpaceClient;
        store: StoreClient;
        subscription: SubscriptionClient;
        upload: UploadClient;
        usage: UsageClient;
    };
    coupon: CouponAPI;
    did(): `did:key:${string}`;
    /**
     * @deprecated - Use client.login instead.
     *
     * Authorize the current agent to use capabilities granted to the passed
     * email account.
     *
     * @param {`${string}@${string}`} email
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     * @param {Iterable<{ can: import('./types.js').Ability }>} [options.capabilities]
     */
    authorize(email: `${string}@${string}`, options?: {
        signal?: AbortSignal | undefined;
        capabilities?: Iterable<{
            can: import('./types.js').Ability;
        }> | undefined;
    } | undefined): Promise<void>;
    /**
     * @param {Account.EmailAddress} email
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     */
    login(email: Account.EmailAddress, options?: {
        signal?: AbortSignal | undefined;
    } | undefined): Promise<Account.Account>;
    /**
     * List all accounts that agent has stored access to. Returns a dictionary
     * of accounts keyed by their `did:mailto` identifier.
     */
    accounts(): Record<`did:mailto:${string}:${string}`, Account.Account>;
    /**
     * Uploads a file to the service and returns the root data CID for the
     * generated DAG.
     *
     * @param {import('./types.js').BlobLike} file - File data.
     * @param {import('./types.js').UploadOptions} [options]
     */
    uploadFile(file: import('./types.js').BlobLike, options?: import("@web3-storage/upload-client/types").UploadOptions | undefined): Promise<import("@web3-storage/upload-client/types").AnyLink>;
    /**
     * Uploads a directory of files to the service and returns the root data CID
     * for the generated DAG. All files are added to a container directory, with
     * paths in file names preserved.
     *
     * @param {import('./types.js').FileLike[]} files - File data.
     * @param {import('./types.js').UploadDirectoryOptions} [options]
     */
    uploadDirectory(files: import('./types.js').FileLike[], options?: import("@web3-storage/upload-client/types").UploadDirectoryOptions | undefined): Promise<import("@web3-storage/upload-client/types").AnyLink>;
    /**
     * Uploads a CAR file to the service.
     *
     * The difference between this function and `capability.store.add` is that the
     * CAR file is automatically sharded and an "upload" is registered, linking
     * the individual shards (see `capability.upload.add`).
     *
     * Use the `onShardStored` callback to obtain the CIDs of the CAR file shards.
     *
     * @param {import('./types.js').BlobLike} car - CAR file.
     * @param {import('./types.js').UploadOptions} [options]
     */
    uploadCAR(car: import('./types.js').BlobLike, options?: import("@web3-storage/upload-client/types").UploadOptions | undefined): Promise<import("@web3-storage/upload-client/types").AnyLink>;
    /**
     * Get a receipt for an executed task by its CID.
     *
     * @param {import('multiformats').UnknownLink} taskCid
     */
    getReceipt(taskCid: import('multiformats').UnknownLink): Promise<import("@ucanto/interface").Receipt<{}, {}, import("@ucanto/interface").Invocation<import("@web3-storage/access").Capability<import("@web3-storage/access").Ability, `${string}:${string}`, unknown>>, import("@web3-storage/access").SigAlg> | undefined>;
    /**
     * Return the default provider.
     */
    defaultProvider(): `did:${string}:${string}`;
    /**
     * The current space.
     */
    currentSpace(): Space | undefined;
    /**
     * Use a specific space.
     *
     * @param {import('./types.js').DID} did
     */
    setCurrentSpace(did: import('./types.js').DID): Promise<void>;
    /**
     * Spaces available to this agent.
     */
    spaces(): Space[];
    /**
     * Create a new space with a given name.
     *
     * @param {string} name
     */
    createSpace(name: string): Promise<import("@web3-storage/access").OwnedSpace>;
    /**
     * Add a space from a received proof.
     *
     * @param {import('./types.js').Delegation} proof
     */
    addSpace(proof: import('./types.js').Delegation): Promise<import("@web3-storage/access").SharedSpace>;
    /**
     * Get all the proofs matching the capabilities.
     *
     * Proofs are delegations with an _audience_ matching the agent DID.
     *
     * @param {import('./types.js').Capability[]} [caps] - Capabilities to
     * filter by. Empty or undefined caps with return all the proofs.
     */
    proofs(caps?: import("@web3-storage/access").Capability<import("@web3-storage/access").Ability, `${string}:${string}`, any>[] | undefined): import("@ucanto/interface").Delegation<import("@web3-storage/access").Capabilities>[];
    /**
     * Add a proof to the agent. Proofs are delegations with an _audience_
     * matching the agent DID.
     *
     * @param {import('./types.js').Delegation} proof
     */
    addProof(proof: import('./types.js').Delegation): Promise<void>;
    /**
     * Get delegations created by the agent for others.
     *
     * @param {import('./types.js').Capability[]} [caps] - Capabilities to
     * filter by. Empty or undefined caps with return all the delegations.
     */
    delegations(caps?: import("@web3-storage/access").Capability<import("@web3-storage/access").Ability, `${string}:${string}`, any>[] | undefined): AgentDelegation<import("@web3-storage/access").Capabilities>[];
    /**
     * Create a delegation to the passed audience for the given abilities with
     * the _current_ space as the resource.
     *
     * @param {import('./types.js').Principal} audience
     * @param {import('./types.js').Abilities[]} abilities
     * @param {Omit<import('./types.js').UCANOptions, 'audience'> & { audienceMeta?: import('./types.js').AgentMeta }} [options]
     */
    createDelegation(audience: import('./types.js').Principal, abilities: import('./types.js').Abilities[], options?: (Omit<import("@ucanto/interface").UCANOptions, "audience"> & {
        audienceMeta?: import("@web3-storage/access").AgentMeta | undefined;
    }) | undefined): Promise<AgentDelegation<import("@web3-storage/access").Capabilities>>;
    /**
     * Revoke a delegation by CID.
     *
     * If the delegation was issued by this agent (and therefore is stored in the
     * delegation store) you can just pass the CID. If not, or if the current agent's
     * delegation store no longer contains the delegation, you MUST pass a chain of
     * proofs that proves your authority to revoke this delegation as `options.proofs`.
     *
     * @param {import('@ucanto/interface').UCANLink} delegationCID
     * @param {object} [options]
     * @param {import('@ucanto/interface').Delegation[]} [options.proofs]
     */
    revokeDelegation(delegationCID: import('@ucanto/interface').UCANLink, options?: {
        proofs?: import("@ucanto/interface").Delegation<import("@web3-storage/access").Capabilities>[] | undefined;
    } | undefined): Promise<StoreCapabilities.Schema.Result<{}, StoreCapabilities.Schema.Error | import("@ucanto/interface").HandlerNotFound | import("@ucanto/interface").HandlerExecutionError | import("@web3-storage/access").InvalidAudience | import("@web3-storage/access").Unauthorized>>;
    /**
     * Removes association of a content CID with the space. Optionally, also removes
     * association of CAR shards with space.
     *
     * ⚠️ If `shards` option is `true` all shards will be deleted even if there is another upload(s) that
     * reference same shards, which in turn could corrupt those uploads.
     *
     * @param {import('multiformats').UnknownLink} contentCID
     * @param {object} [options]
     * @param {boolean} [options.shards]
     */
    remove(contentCID: import('multiformats').UnknownLink, options?: {
        shards?: boolean | undefined;
    } | undefined): Promise<void>;
}
import { AccessClient } from './capability/access.js';
import { FilecoinClient } from './capability/filecoin.js';
import { StoreClient } from './capability/store.js';
import { SpaceClient } from './capability/space.js';
import { SubscriptionClient } from './capability/subscription.js';
import { UploadClient } from './capability/upload.js';
import { UsageClient } from './capability/usage.js';
import { Base } from './base.js';
import { CouponAPI } from './coupon.js';
import * as Account from './account.js';
import { Space } from './space.js';
import { Delegation as AgentDelegation } from './delegation.js';
import { Store as StoreCapabilities } from '@web3-storage/capabilities';
export { AccessClient, FilecoinClient, StoreClient, SpaceClient, SubscriptionClient, UploadClient, UsageClient };
//# sourceMappingURL=client.d.ts.map