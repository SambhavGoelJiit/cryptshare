export { fromEmail };
export function list({ agent }: {
    agent: API.Agent;
}, { account }?: {
    account?: `did:mailto:${string}` | undefined;
}): Record<`did:mailto:${string}:${string}`, Account>;
export function login({ agent }: {
    agent: API.Agent;
}, email: EmailAddress, options?: {
    signal?: AbortSignal | undefined;
} | undefined): Promise<API.Result<Account, Error>>;
/**
 * @typedef {object} Model
 * @property {API.DidMailto} id
 * @property {API.Agent} agent
 * @property {API.Delegation[]} proofs
 */
export class Account {
    /**
     * @param {Model} model
     */
    constructor(model: Model);
    model: Model;
    plan: AccountPlan;
    get agent(): API.Agent<import("@web3-storage/access/types").Service>;
    get proofs(): API.Delegation<API.Capabilities>[];
    did(): `did:mailto:${string}:${string}`;
    toEmail(): `${string}@${string}`;
    /**
     * @param {API.Delegation} proof
     */
    addProof(proof: API.Delegation): void;
    toJSON(): {
        id: `did:mailto:${string}:${string}`;
        proofs: API.DelegationJSON<API.Delegation<API.Capabilities>>[];
    };
    /**
     * Provisions given `space` with this account.
     *
     * @param {API.SpaceDID} space
     * @param {object} input
     * @param {API.ProviderDID} [input.provider]
     * @param {API.Agent} [input.agent]
     */
    provision(space: API.SpaceDID, input?: {
        provider?: `did:web:${string}` | undefined;
        agent?: API.Agent<import("@web3-storage/access/types").Service> | undefined;
    }): Promise<API.Result<{}, API.Failure | API.HandlerNotFound | API.HandlerExecutionError | API.InvalidAudience | API.Unauthorized>>;
    /**
     * Saves account in the agent store so it can be accessed across sessions.
     *
     * @param {object} input
     * @param {API.Agent} [input.agent]
     */
    save({ agent }?: {
        agent?: API.Agent<import("@web3-storage/access/types").Service> | undefined;
    }): Promise<API.Result<API.Unit, Error>>;
}
export class AccountPlan {
    /**
     * @param {Model} model
     */
    constructor(model: Model);
    model: Model;
    /**
     * Gets information about the plan associated with this account.
     */
    get(): Promise<API.Result<API.PlanGetSuccess, API.HandlerNotFound | API.HandlerExecutionError | API.InvalidAudience | API.Unauthorized | API.PlanGetFailure>>;
    /**
     * Sets the plan associated with this account.
     *
     * @param {import('@ucanto/interface').DID} productDID
     */
    set(productDID: import('@ucanto/interface').DID): Promise<API.Result<API.Unit, API.HandlerNotFound | API.HandlerExecutionError | API.InvalidAudience | API.Unauthorized | API.PlanSetFailure>>;
    subscriptions(): Promise<API.Result<import("@web3-storage/capabilities/types").SubscriptionListSuccess, API.Failure | API.HandlerNotFound | API.HandlerExecutionError | API.InvalidAudience | API.Unauthorized>>;
}
export type EmailAddress = import('@web3-storage/did-mailto').EmailAddress;
export type Model = {
    id: API.DidMailto;
    agent: API.Agent;
    proofs: API.Delegation[];
};
import { fromEmail } from '@web3-storage/did-mailto';
import * as API from './types.js';
import { Delegation } from '@web3-storage/access/agent';
//# sourceMappingURL=account.d.ts.map